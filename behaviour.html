<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="value-observer.html">

<script>
    /**
     * `flowbased-behaviour`
     * Connect events from components to other components or to properties without coding
     *
     *
     * @author veith
     * @demo demo/index.html
     *
     * @polymerBehavior PolymerFlowBasedProgramming
     */
    PolymerFlowBasedProgramming = {
        properties: {
            _PolymerFlowBasedProgrammingEvents: {
                type: Array,
                value: function () {
                    return [];
                }()
            },
            _PolymerFlowBasedProgrammingTraceFlow: {
                type: Boolean,
                value: false
            }
        },
        attached: function () {
            var plantUMLArray = [];
            var WSources = {};
            var WTargets = {};
            var self = this;
            var wirebundle = {};
            var tmp_PolymerFlowBasedProgrammingEvents = new Array;
            // get all elements which live in the host
            Polymer.dom(this.root).querySelectorAll('*').forEach(function (element) {
                for (var i = 0; i < element.attributes.length; i++) {
                    // collect receiving tags
                    if (element.attributes[i].name.startsWith('Æ’-')) {
                        // get method name and convert to camel case
                        var methodname = element.attributes[i].name.substr(2).replace(/-([a-z])/g, function (g) {
                            return g[1].toUpperCase();
                        });
                        var mwire = element.attributes[i].value;

                        // collect receiver
                        mwire.split(',').forEach(function (w) {
                            var receivingWire = w.trim();
                            if (!wirebundle[receivingWire]) {
                                wirebundle[receivingWire] = [];
                            }
                            wirebundle[receivingWire].push({"element": element, "method": methodname});
                            if (self._PolymerFlowBasedProgrammingTraceFlow) {


                                if (!WTargets[receivingWire]) {
                                    WTargets[receivingWire] = [];
                                }
                                WTargets[receivingWire].push({"target": element.nodeName, "event": methodname, "path": self.getElementPath(element)});
                            }
                        });

                    }

                    // collect sending tags
                    if (element.attributes[i].name.startsWith('@-')) {

                        var eventname = element.attributes[i].name.substr(2);
                        var useSetter = false;
                        var wire;


                        /**
                         * register event on current element
                         * @param eventname
                         */
                        function registerEvent(eventname, useSetter, wire) {
                            var handler = function (e) {
                                // Werte setzen
                                if (useSetter) {

                                    self.set(wire, e.detail, self);
                                } else {

                                    // Methoden aufrufen
                                    if (wirebundle[wire]) {
                                        wirebundle[wire].forEach(function (receiver) {
                                            if (typeof receiver.element[receiver.method] === 'function') {
                                                receiver.element[receiver.method](e.detail);
                                            } else {
                                                console.warn(receiver.method + ' is neither a listener nor a function of ' + receiver.element.nodeName)
                                            }

                                        });
                                    }
                                }
                            };

                            element.addEventListener(eventname, handler, false);
                            tmp_PolymerFlowBasedProgrammingEvents.push({
                                "element": element,
                                "event": eventname,
                                "handler": handler
                            });
                        }

                        //----

                        var fwires = element.attributes[i].value;
                        fwires.split(',').forEach(function (fwire) {
                            useSetter = false;
                            var trimmedWire = fwire.trim();
                            if (trimmedWire.startsWith('((')) {
                                wire = trimmedWire.substring(2, trimmedWire.length - 2);
                                useSetter = true;
                                if (self._PolymerFlowBasedProgrammingTraceFlow) {
                                    plantUMLArray.push({
                                        type: "setValue",
                                        sourceElement: element.nodeName,
                                        sourceEvent: eventname,
                                        wire: null,
                                        targetElement: wire,
                                        targetEvent: null
                                    })
                                }

                            } else {
                                wire = trimmedWire;
                                if (!WSources[element.nodeName]) {
                                    WSources[element.nodeName] = [];
                                }
                                WSources[element.nodeName].push({"wire": wire, "event": eventname, "path": self.getElementPath(element)});


                            }

                            // register click on tap event like polymer
                            if (eventname === 'tap') {
                                eventname = 'click';
                            }

                            registerEvent(eventname,useSetter, wire);
                        });


                    }
                }
            });
            self._PolymerFlowBasedProgrammingEvents = tmp_PolymerFlowBasedProgrammingEvents;


            if (self._PolymerFlowBasedProgrammingTraceFlow) {
                for (var sourceElement in WSources) {
                    if (WSources.hasOwnProperty(sourceElement)) {
                        WSources[sourceElement].forEach(function (s) {
                            if (WTargets[s.wire]) {
                                WTargets[s.wire].forEach(function (t) {
                                    plantUMLArray.push({
                                        sourceElement: sourceElement,
                                        sourceEvent: s.event,
                                        wire: s.wire,
                                        targetElement: t.target, targetEvent: t.event
                                    });
                                });
                            } else {
                                // no corresponding wire available
                                plantUMLArray.push({
                                    type: "noTarget",
                                    sourceElement: sourceElement,
                                    sourceEvent: s.event,
                                    wire: s.wire,
                                    targetElement: undefined, targetEvent: undefined
                                });
                            }
                        })
                    }
                }
                self._makePUML(plantUMLArray);
            }
        },
        detached: function () {
            var self = this;
            // remove event listeners
            this._PolymerFlowBasedProgrammingEvents.forEach(function (e) {
                e.element.removeEventListener(e.event, e.hadler);
            })
        },
        _makePUML: function (data) {
            var UML = '@startuml\nleft to right direction\n skinparam interface {\n backgroundColor lightgrey \nborderColor black\n}\n' +
                'skinparam component {\nArrowColor #225522\nArrowFontColor #666666\n}\n';
            // nodes listen
            var toCamel = function (str) {
                return str.toLowerCase().replace(/-([a-z])/g, function (g) {
                    return g[1].toUpperCase();
                });
            };

            var alreadyDeclaredNode = [];
            data.forEach(function (interaction) {
                var sourceElement = toCamel(interaction.sourceElement);
                if (interaction.targetElement) {
                    var targetElement = toCamel(interaction.targetElement);


                    if (interaction.type === "setValue") {
                        if (alreadyDeclaredNode.indexOf(targetElement) == -1) {
                            UML = UML + 'database ' + targetElement + ' #lightgray\n';
                            alreadyDeclaredNode.push(targetElement);
                        }
                    } else {
                        if (alreadyDeclaredNode.indexOf(targetElement) == -1) {
                            UML = UML + 'node ' + targetElement + ' #white\n';
                            alreadyDeclaredNode.push(targetElement);
                        }
                    }
                    if (alreadyDeclaredNode.indexOf(sourceElement) == -1) {
                        UML = UML + 'node ' + sourceElement + ' #white\n';
                        alreadyDeclaredNode.push(sourceElement);
        }

                    if (alreadyDeclaredNode.indexOf(toCamel('interface-' + interaction.sourceEvent)) == -1) {
                        UML = UML + 'interface ' + toCamel(interaction.sourceEvent) + ' as ' + toCamel('interface-' + interaction.sourceEvent) + ' \n';
                        UML = UML + sourceElement + ' .. ' + toCamel('interface-' + interaction.sourceEvent) + ' #gray\n';

                        alreadyDeclaredNode.push(toCamel('interface-' + interaction.sourceEvent));
                    }
                    if (interaction.type != "setValue" && alreadyDeclaredNode.indexOf(toCamel('interface-' + interaction.targetEvent)) == -1) {
                        UML = UML + 'interface ' + toCamel(interaction.targetEvent) + ' as ' + toCamel('interface-' + interaction.targetEvent) + ' \n';
                        UML = UML + toCamel('interface-' + interaction.targetEvent) + ' .. ' + targetElement + ' #gray\n';
                        alreadyDeclaredNode.push(toCamel('interface-' + interaction.targetEvent));
                    }
                } else {
                    // ins nirvana

                    UML = UML + 'interface ' + toCamel(interaction.sourceEvent) + ' as ' + toCamel('interface-' + interaction.sourceEvent) + ' \n';
                    UML = UML + sourceElement + ' ~~ ' + toCamel('interface-' + interaction.sourceEvent) + ' #red\n';

                    alreadyDeclaredNode.push(toCamel('interface-' + interaction.sourceEvent));
                    if(alreadyDeclaredNode.indexOf("nirvana") == -1){
                        UML = UML + 'cloud "no Target" as nirvana #red\n';
                        alreadyDeclaredNode.push("nirvana");
                    }
                }

            });

            // interfaces mit Elementen verbinden


            // verbinder machen
            data.forEach(function (interaction) {
                if (interaction.targetElement) {
                    var targetElement = interaction.targetElement.toLowerCase().replace(/-([a-z])/g, function (g) {
                        return g[1].toUpperCase();
                    });
                    var sourceElement = interaction.sourceElement.toLowerCase().replace(/-([a-z])/g, function (g) {
                        return g[1].toUpperCase();
                    });
                    if (interaction.type === "setValue") {
                        UML = UML + toCamel('interface-' + interaction.sourceEvent) + ' --> ' + toCamel( interaction.targetElement) + '\n';

                    } else if (interaction.type === "noTarget") {
                        UML = UML + toCamel('interface-' + interaction.sourceEvent) + ' -- . :' + toCamel(interaction.wire) + '\n';

                    } else {
                        UML = UML + toCamel('interface-' + interaction.sourceEvent) + ' --> ' + toCamel('interface-' + interaction.targetEvent) + ' :' + toCamel(interaction.wire) + '\n';
                    }
                } else {
                    // ins nirvana
                    UML = UML + toCamel('interface-' + interaction.sourceEvent) + ' .>> nirvana\n';
                }

            });
            UML = UML + '@enduml';
            console.log(UML)
        },
         getElementPath :function(el){
            var path = el.nodeName;
            var parent = el.parentNode;
            while(parent){
                path = parent.nodeName + '/' + path;
                parent = parent.parentNode;
            }
            return path;
        }

    }
    ;
</script>
