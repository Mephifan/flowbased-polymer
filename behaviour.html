<link rel="import" href="../polymer/polymer.html">


<script>

   /*
   *
   *
   *@author veith zäch
   */


  /*
   * @polymerBehavior Polymer.FlowBasedProgramming
   */
  Polymer.FlowBasedProgramming = {
    properties: {
      _PolymerFlowBasedProgrammingEvents: {
        type: Array,
        value: function () {
          return [];
        }()
      }
    },
    ready: function () {
      var WSources = {};
      var self = this;
      var wirebundle = {};
      var tmp_PolymerFlowBasedProgrammingEvents = new Array;


      // get all elements which live in the host
      Polymer.dom(this.root).querySelectorAll('*').forEach(function (element) {


        for (var i = 0; i < element.attributes.length; i++) {
          // collect receiving tags
          if (element.attributes[i].name.startsWith('ƒ-')) {
            // get method name and convert to camel case
            var methodname = element.attributes[i].name.substr(2).replace(/-([a-z])/g, function (g) {
              return g[1].toUpperCase();
            });
            var mwire = element.attributes[i].value;

            // collect receiver
            mwire.split(',').forEach(function (w) {
              var receivingWire = w.trim();
              if (!wirebundle[receivingWire]) {
                wirebundle[receivingWire] = [];
              }
              wirebundle[receivingWire].push({"element": element, "method": methodname});


            });

          }

          // collect sending tags
          if (element.attributes[i].name.startsWith('@-')) {

            var eventname = element.attributes[i].name.substr(2);
            var useSetter = false;
            var wire;


            /**
             * register event on current element
             * @param eventname
             */
            function registerEvent(eventname, type, wire) {
              var handler = function (e) {
                // Werte setzen
                if (type === "setValue") {
                  self.set(wire, e.detail, self);
                }
                if (type === "fire") {
                  // find properties in wire
                  var match = wire.match(/([a-z\-_]+)(?!\()([a-z0-9\-\._]+)/gi);

                  if (match !== null && match.length > 1) {
                    var prop = match[1];
                    var theEvent = match[0];
                    var customEvent = new Event(theEvent, {bubbles: false});
                    customEvent.detail = self[prop];
                    self.dispatchEvent(customEvent);
                    // self.fire(theEvent, self[prop], {bubbles: false});
                  } else {

                    var customEvent = new Event(wire, {bubbles: false});
                    customEvent.detail = e.detail;
                    self.dispatchEvent(customEvent);
                    // self.fire(wire, e.detail, {bubbles: false});
                  }
                }
                if (type === "fireBubble") {

                  // find properties in wire
                  var match = wire.match(/([a-z\-_]+)(?!\()([a-z0-9\-\._]+)/gi);
                  if (match !== null && match.length > 1) {
                    var prop = match[1];
                    var theEvent = match[0];
                    var customEvent = new Event(theEvent, {bubbles: true});
                    customEvent.detail = self[prop];

                    self.dispatchEvent(customEvent);

                  } else {

                    var customEvent = new Event(wire, {bubbles: true});
                    customEvent.detail = e.detail;
                    self.dispatchEvent(customEvent);

                  }

                }
                if (type === "call") {
                  /**
                   * Prüfe ob die Funktion mit einem Wert aus dem Host oder mit den Details des Events ausgeführt werden soll.
                   * --wire(hostName) ==> wirft this.hostName in die Funktion sonst wird e.detail verwendet
                   *
                   */
                  var match = wire.match(/([a-z\-_]+)(?!\()([a-z0-9\-\._]+)/gi);
                  var effectiveWire = wire;
                  var detailData = e.detail;
                  if (match !== null && match.length > 1) {
                    detailData = self[match[1]];
                    effectiveWire = match[0];
                  }


                  // Methoden aufrufen
                  if (wirebundle[effectiveWire]) {
                    wirebundle[effectiveWire].forEach(function (receiver) {
                      if (typeof receiver.element[receiver.method] === 'function') {
                        // array spreaden
                        if(Array.isArray(detailData) && receiver.element[receiver.method].length >1){
                          receiver.element[receiver.method].apply(null, detailData);
                        }else{
                        receiver.element[receiver.method](detailData);
                        }

                      } else {
                        console.warn(receiver.method + ' is neither a listener nor a function of ' + receiver.element.nodeName)
                      }

                    });
                  }
                }
              };

              element.addEventListener(eventname, handler, false);
              tmp_PolymerFlowBasedProgrammingEvents.push({
                "element": element,
                "event": eventname,
                "handler": handler
              });
            }

            //----

            var fwires = element.attributes[i].value;
            fwires.split(',').forEach(function (fwire) {
              useSetter = false;
              var trimmedWire = fwire.trim();


              if (!WSources[element._flowName]) {
                WSources[element._flowName] = [];

              }

              var type = "call";
              if (trimmedWire.startsWith('((')) {
                wire = trimmedWire.substring(2, trimmedWire.length - 2);
                type = "setValue";


              } else if (trimmedWire.startsWith('^')) {
                wire = trimmedWire.substring(1);
                type = "fire";
                if (trimmedWire.startsWith('^^')) {
                  wire = trimmedWire.substring(2);
                  type = "fireBubble";
                }


              } else {
                wire = trimmedWire;
                type = "call";

                WSources[element._flowName].push({
                  "node": element._flowName,
                  "wire": wire,
                  "event": eventname,
                  "path": self._getElementPath(element)
                });


              }

              // register click on tap event like polymer
              if (eventname === 'tap') {
                eventname = 'click';
              }

              registerEvent(eventname, type, wire);
            });


          }
        }
      });

      self._PolymerFlowBasedProgrammingEvents = tmp_PolymerFlowBasedProgrammingEvents;

    },

    detached: function () {
      var self = this;
      // remove event listeners
      this._PolymerFlowBasedProgrammingEvents.forEach(function (e) {
        e.element.removeEventListener(e.event, e.hadler);
      })
    },

    _getElementPath: function (el) {
      var path = el.nodeName;
      var parent = el.parentNode;
      while (parent) {
        path = parent.nodeName + '/' + path;
        parent = parent.parentNode;
      }
      return path;
    }

  }
  ;
</script>
